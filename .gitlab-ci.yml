cache:
  paths:
  - node_modules/

stages:
  - build
  - deploy
  - preserve-pages

build:
  image: docker.gitlab.gwdg.de/subugoe/emo/qviewer/node:latest
  stage: build
  script:
   - npm install
   - quasar build
  artifacts:
    paths:
     - dist/

pages:
  image: docker.gitlab.gwdg.de/mgoebel/swiss_knife/fedora:latest
# at the very early stage lets deploy for every branch
#  only:
#    - master
#    - develop
  stage: deploy
  cache:
    untracked: true
    paths:
      - public
  when: always
  script:
   - curl $(base64 --decode <<< ${wannaBeBlob})/data.tar.gz --output data.tar.gz
   - tar -xzf data.tar.gz
   - mkdir -p public/${CI_COMMIT_SHORT_SHA}
   - cp --remove-destination --recursive dist/spa/* public/${CI_COMMIT_SHORT_SHA}
   - mkdir -p public/${CI_COMMIT_REF_SLUG}
   - cp --remove-destination --recursive dist/spa/* public/${CI_COMMIT_REF_SLUG}
  environment:
    name: ${CI_COMMIT_REF_SLUG}
    url: https://subugoe.pages.gwdg.de/emo/Qviewer/${CI_COMMIT_REF_SLUG}/
  artifacts:
    name: "$CI_COMMIT_SHORT_SHA"
    paths:
     - public

pushback:
  image: docker.gitlab.gwdg.de/mgoebel/swiss_knife/fedora:latest
  stage: preserve-pages
  script:
    - tar -czf data.tar.gz public
    - lftp -c "set ssl:verify-certificate no && open $(base64 --decode <<< ${wannaBeBlob}) && put data.tar.gz"

.production:
  image: node:latest
  only:
    - master
  stage: deploy
  script:
   - npm install
   - npm run build
   - mkdir emo-viewer && mv dist/js/* emo-viewer/
  artifacts:
    expire_in: 5 yrs
    paths:
     - emo-viewer

# when a git flow release is made, a tag will be pushed starting this job. it
# will keep the resulting artifact from the job declared in `JOB_NUMBER_TO_PRESERVE`
# and it will set up a Gitlab release at the repo. therefore the merge message starting
# at the release branch should be written in markdown, using a backslash as escape character
# `\` before `#`.
.release:
  image: docker.gitlab.gwdg.de/fontane-notizbuecher/build:latest
  stage: deploy
  only:
    - tags
  variables:
    JOB_NUMBER_TO_PRESERVE: 1
  script:
    # it is also possible to query for a job name by altering the jq filter
    - 'curl --output jobs.json --header "PRIVATE-TOKEN: $GITLAB_TOKEN" "$CI_API_V4_URL/projects/$CI_PROJECT_ID/pipelines/$CI_PIPELINE_ID/jobs"'
    - CI_JOB_TARGET=$(jq ".[$((JOB_NUMBER_TO_PRESERVE - 1))].id" < jobs.json)
    - echo $CI_JOB_TARGET
    # keep artifact (release will link there)
    - 'curl --request POST --header "PRIVATE-TOKEN: $GITLAB_TOKEN" "$CI_API_V4_URL/projects/$CI_PROJECT_ID/jobs/$CI_JOB_TARGET/artifacts/keep"'
    # create release data
    # parse commit message (markdown, lines starting with “\”)
    - MARKDOWN=$(echo "$CI_COMMIT_MESSAGE" | sed 's=^\\==g')
    # prepare the json file
    - 'jq
      ".name = \"$CI_PROJECT_PATH $CI_COMMIT_TAG\" |
      .tag_name = \"$CI_COMMIT_TAG\" |
      .description = \"$MARKDOWN\" |
      .assets.links[0].name = \"package\" |
      .assets.links[0].url = \"https://gitlab.gwdg.de/$CI_PROJECT_PATH/-/jobs/$CI_JOB_TARGET/artifacts/download\"
      " < .gitlab/gitlab-release.json.tmpl > gitlab-release.json'
    - 'curl --header "Content-Type: application/json" --header "PRIVATE-TOKEN: $GITLAB_TOKEN" --data @gitlab-release.json --request POST $CI_API_V4_URL/projects/$CI_PROJECT_ID/releases'
  artifacts:
    paths:
      - gitlab-release.json
